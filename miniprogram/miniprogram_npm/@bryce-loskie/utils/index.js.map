{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to2, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to2, key) && key !== except)\n        __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to2;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  assert: () => assert,\n  at: () => at,\n  blankObject: () => blankObject,\n  clamp: () => clamp,\n  clampArrayRange: () => clampArrayRange,\n  clearUndefined: () => clearUndefined,\n  createControlledPromise: () => createControlledPromise,\n  createEventHook: () => createEventHook,\n  customAlphabet: () => customAlphabet,\n  debounce: () => debounce,\n  ensurePrefix: () => ensurePrefix,\n  ensureSuffix: () => ensureSuffix,\n  fillWith: () => fillWith,\n  flattenArrayable: () => flattenArrayable,\n  getDeep: () => getDeep,\n  hasOwnProperty: () => hasOwnProperty,\n  hash: () => hash,\n  isBoolean: () => isBoolean,\n  isBrowser: () => isBrowser,\n  isClient: () => isClient,\n  isDef: () => isDef,\n  isEmptyObject: () => isEmptyObject,\n  isError: () => isError,\n  isFunction: () => isFunction,\n  isKeyOf: () => isKeyOf,\n  isLooseFalsy: () => isLooseFalsy,\n  isLooseTruthy: () => isLooseTruthy,\n  isNumber: () => isNumber,\n  isObject: () => isObject,\n  isPromise: () => isPromise,\n  isStrictFalsy: () => isStrictFalsy,\n  isStrictTruthy: () => isStrictTruthy,\n  isString: () => isString,\n  isTruthy: () => isTruthy,\n  isWindow: () => isWindow,\n  last: () => last,\n  lastPromiseFn: () => lastPromiseFn,\n  lockPromiseFn: () => lockPromiseFn,\n  memorize: () => memorize,\n  memorizePromise: () => memorizePromise,\n  mergeArrayable: () => mergeArrayable,\n  move: () => move,\n  nanoid: () => nanoid,\n  noNull: () => noNull,\n  noop: () => noop,\n  notUndefined: () => notUndefined,\n  objectOmit: () => objectOmit,\n  objectPick: () => objectPick,\n  partition: () => partition,\n  range: () => range,\n  rangeWithStart: () => rangeWithStart,\n  remove: () => remove,\n  retryPromiseFn: () => retryPromiseFn,\n  run: () => run,\n  runAll: () => runAll,\n  runOnce: () => runOnce,\n  singletonPromiseFn: () => singletonPromiseFn,\n  slash: () => slash,\n  sleep: () => sleep,\n  sum: () => sum,\n  throttle: () => throttle,\n  timestamp: () => timestamp,\n  to: () => to,\n  toArray: () => toArray,\n  toString: () => toString,\n  uniq: () => uniq,\n  uuid: () => uuid\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/misc.ts\nvar uuid = () => {\n  return Array.from({ length: 16 }, () => Math.floor(Math.random() * 256).toString(16).padStart(2, \"0\")).join(\"\");\n};\nvar assert = (condition, message) => {\n  if (!condition) {\n    if (isError(message))\n      throw message;\n    else\n      throw new Error(message || \"assertion failed\");\n  }\n};\nvar toString = (v) => Object.prototype.toString.call(v);\nfunction noop() {\n}\nvar timestamp = () => Date.now();\nvar blankObject = () => /* @__PURE__ */ Object.create(null);\nvar run = (fn) => fn();\nvar runAll = (fns) => fns.forEach(run);\nvar runOnce = (fn) => {\n  let ran = false;\n  return function(...args) {\n    if (ran)\n      return;\n    ran = true;\n    fn.apply(this, args);\n  };\n};\nvar hash = (str) => {\n  let hash2 = 5381;\n  let i = str.length;\n  while (i--)\n    hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);\n  return hash2 >>> 0;\n};\n\n// src/is.ts\nvar isBrowser = () => typeof window !== \"undefined\";\nvar isDef = (val) => typeof val !== \"undefined\";\nvar isBoolean = (val) => typeof val === \"boolean\";\nvar isFunction = (val) => typeof val === \"function\";\nvar isNumber = (val) => typeof val === \"number\";\nvar isString = (val) => typeof val === \"string\";\nvar isObject = (val) => toString(val) === \"[object Object]\";\nvar isWindow = (val) => toString(val) === \"[object Window]\" && typeof window !== \"undefined\";\nvar isError = (val) => toString(val) === \"[object Error]\" && val instanceof Error;\nvar isLooseFalsy = (val) => [\"\", null, void 0].includes(val);\nvar isStrictFalsy = (val) => [\"\", null, void 0, 0].includes(val);\nvar isLooseTruthy = (val) => !isLooseFalsy(val);\nvar isStrictTruthy = (val) => !isStrictFalsy(val);\nvar isEmptyObject = (val) => isObject(val) && Object.keys(val).length === 0;\nvar isClient = isBrowser();\nvar isPromise = (val) => {\n  return val && toString(val) === \"[object Promise]\" && isFunction(val.then) && isFunction(val.catch) && val instanceof Promise;\n};\n\n// src/array.ts\nfunction toArray(array) {\n  if (Array.isArray(array))\n    return array;\n  return [array];\n}\nvar flattenArrayable = (array) => {\n  return toArray(array).flat(1);\n};\nvar at = (array, index) => {\n  const len = array.length;\n  if (!len)\n    return void 0;\n  if (index < 0)\n    index += len;\n  return array[index];\n};\nvar clampArrayRange = (index, array) => {\n  const len = array.length;\n  return clamp(index, 0, len - 1);\n};\nvar last = (array) => {\n  return at(array, -1);\n};\nvar mergeArrayable = (...args) => {\n  return args.flatMap((item) => toArray(item));\n};\nvar move = (arr, from, to2) => {\n  arr.splice(to2, 0, arr.splice(from, 1)[0]);\n  return arr;\n};\nvar partition = (array, ...filters) => {\n  const result = new Array(filters.length + 1).fill(null).map(() => []);\n  array.forEach((e, idx, arr) => {\n    let i = 0;\n    for (const filter of filters) {\n      if (filter(e, idx, arr)) {\n        result[i].push(e);\n        return;\n      }\n      i += 1;\n    }\n    result[i].push(e);\n  });\n  return result;\n};\nvar range = (stop) => {\n  return Array.from({ length: stop }, (_, idx) => idx);\n};\nvar rangeWithStart = (start, stop) => {\n  return Array.from({ length: stop - start }, (_, idx) => start + idx);\n};\nfunction fillWith(count, item) {\n  return Array.from({ length: count }, isFunction(item) ? item : () => item);\n}\nvar remove = (array, value) => {\n  if (!array)\n    return false;\n  const index = array.indexOf(value);\n  if (index >= 0) {\n    array.splice(index, 1);\n    return true;\n  }\n  return false;\n};\nvar uniq = (array) => {\n  if (!Array.isArray(array))\n    return array;\n  return Array.from(new Set(array));\n};\n\n// src/math.ts\nvar clamp = (n, min, max) => {\n  return Math.min(max, Math.max(min, n));\n};\nvar sum = (...args) => {\n  return flattenArrayable(args).reduce((sum2, value) => sum2 + value, 0);\n};\n\n// src/string.ts\nvar slash = (str) => {\n  return str.replace(/\\\\/g, \"/\");\n};\nvar ensurePrefix = (str, prefix) => {\n  if (!str.startsWith(prefix))\n    return prefix + str;\n  return str;\n};\nvar ensureSuffix = (str, suffix) => {\n  if (!str.endsWith(suffix))\n    return str + suffix;\n  return str;\n};\n\n// src/promise.ts\nvar sleep = (ms, callback) => {\n  let timer = null;\n  const clear = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  };\n  const p = new Promise((resolve) => {\n    timer = setTimeout(() => {\n      callback == null ? void 0 : callback();\n      resolve();\n    }, ms);\n  });\n  Object.defineProperty(p, \"clear\", {\n    value: clear,\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n  return p;\n};\nfunction to(promise, errorExt) {\n  return promise.then((data) => [null, data]).catch((err) => {\n    if (errorExt) {\n      const parsedError = Object.assign({}, err, errorExt);\n      return [parsedError, void 0];\n    }\n    return [err, void 0];\n  });\n}\nvar lockPromiseFn = (fn) => {\n  let lock = false;\n  return async function(...args) {\n    if (lock)\n      return;\n    lock = true;\n    try {\n      const ret = await fn(...args);\n      lock = false;\n      return ret;\n    } catch (error) {\n      lock = false;\n      throw error;\n    }\n  };\n};\nvar retryPromiseFn = (fn, options = {}) => {\n  const { times = 3, onFail = noop } = options;\n  return async function(...args) {\n    for (let i = 0; i < times; i++) {\n      try {\n        return await fn(...args);\n      } catch (error) {\n        await Promise.resolve(onFail(error));\n        if (i === times - 1)\n          throw error;\n      }\n    }\n  };\n};\nvar lastPromiseFn = (fn) => {\n  let calledTimes = 0;\n  let resolvedTimes = 0;\n  return function(...args) {\n    calledTimes++;\n    return new Promise((resolve, reject) => {\n      fn(...args).then((ret) => {\n        if (++resolvedTimes === calledTimes)\n          resolve(ret);\n      }).catch(reject);\n    });\n  };\n};\nfunction singletonPromiseFn(fn) {\n  let _promise;\n  function wrapper() {\n    if (!_promise)\n      _promise = fn();\n    return _promise;\n  }\n  wrapper.reset = async () => {\n    const _prev = _promise;\n    _promise = void 0;\n    if (_prev)\n      await _prev;\n  };\n  return wrapper;\n}\nfunction createControlledPromise() {\n  let resolve, reject;\n  const promise = new Promise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  promise.resolve = resolve;\n  promise.reject = reject;\n  return promise;\n}\n\n// node_modules/.pnpm/throttle-debounce@5.0.0/node_modules/throttle-debounce/esm/index.js\nfunction throttle(delay, callback, options) {\n  var _ref = options || {}, _ref$noTrailing = _ref.noTrailing, noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing, _ref$noLeading = _ref.noLeading, noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading, _ref$debounceMode = _ref.debounceMode, debounceMode = _ref$debounceMode === void 0 ? void 0 : _ref$debounceMode;\n  var timeoutID;\n  var cancelled = false;\n  var lastExec = 0;\n  function clearExistingTimeout() {\n    if (timeoutID) {\n      clearTimeout(timeoutID);\n    }\n  }\n  function cancel(options2) {\n    var _ref2 = options2 || {}, _ref2$upcomingOnly = _ref2.upcomingOnly, upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;\n    clearExistingTimeout();\n    cancelled = !upcomingOnly;\n  }\n  function wrapper() {\n    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {\n      arguments_[_key] = arguments[_key];\n    }\n    var self = this;\n    var elapsed = Date.now() - lastExec;\n    if (cancelled) {\n      return;\n    }\n    function exec() {\n      lastExec = Date.now();\n      callback.apply(self, arguments_);\n    }\n    function clear() {\n      timeoutID = void 0;\n    }\n    if (!noLeading && debounceMode && !timeoutID) {\n      exec();\n    }\n    clearExistingTimeout();\n    if (debounceMode === void 0 && elapsed > delay) {\n      if (noLeading) {\n        lastExec = Date.now();\n        if (!noTrailing) {\n          timeoutID = setTimeout(debounceMode ? clear : exec, delay);\n        }\n      } else {\n        exec();\n      }\n    } else if (noTrailing !== true) {\n      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);\n    }\n  }\n  wrapper.cancel = cancel;\n  return wrapper;\n}\nfunction debounce(delay, callback, options) {\n  var _ref = options || {}, _ref$atBegin = _ref.atBegin, atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;\n  return throttle(delay, callback, {\n    debounceMode: atBegin !== false\n  });\n}\n\n// node_modules/.pnpm/registry.npmmirror.com+nanoid@4.0.0/node_modules/nanoid/non-secure/index.js\nvar urlAlphabet = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nvar customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = \"\";\n    let i = size;\n    while (i--) {\n      id += alphabet[Math.random() * alphabet.length | 0];\n    }\n    return id;\n  };\n};\nvar nanoid = (size = 21) => {\n  let id = \"\";\n  let i = size;\n  while (i--) {\n    id += urlAlphabet[Math.random() * 64 | 0];\n  }\n  return id;\n};\n\n// src/guards.ts\nfunction noNull(v) {\n  return v !== null;\n}\nfunction notUndefined(v) {\n  return v !== void 0;\n}\nfunction isTruthy(v) {\n  return Boolean(v);\n}\n\n// src/object.ts\nfunction clearUndefined(obj) {\n  Object.keys(obj).forEach((key) => obj[key] === void 0 ? delete obj[key] : {});\n  return obj;\n}\nfunction hasOwnProperty(obj, v) {\n  if (obj == null)\n    return false;\n  return Object.prototype.hasOwnProperty.call(obj, v);\n}\nfunction objectPick(obj, keys, omitUndefined = false) {\n  return keys.reduce((n, k) => {\n    if (k in obj) {\n      if (!omitUndefined || !obj[k] === void 0)\n        n[k] = obj[k];\n    }\n    return n;\n  }, {});\n}\nfunction objectOmit(obj, keys, omitUndefined = false) {\n  const oldKeys = Object.keys(obj);\n  return oldKeys.reduce((acc, key) => {\n    if (!toArray(keys).includes(key)) {\n      if (!omitUndefined || !obj[key] === void 0) {\n        acc[key] = obj[key];\n      }\n    }\n    return acc;\n  }, {});\n}\nfunction isKeyOf(obj, k) {\n  return k in obj;\n}\nvar getDeep = (obj, path) => {\n  try {\n    return path.split(\".\").reduce((acc, key) => acc[key], obj);\n  } catch (_) {\n    return void 0;\n  }\n};\n\n// src/event-hook.ts\nfunction createEventHook() {\n  const fns = [];\n  const off = (fn) => {\n    const index = fns.indexOf(fn);\n    if (index !== -1)\n      fns.splice(index, 1);\n  };\n  const on = (fn) => {\n    fns.push(fn);\n    return {\n      off: () => off(fn)\n    };\n  };\n  const trigger = (param) => {\n    fns.forEach((fn) => fn(param));\n  };\n  return {\n    on,\n    off,\n    trigger\n  };\n}\n\n// src/memorize.ts\nfunction memorizePromise(fn) {\n  let cache;\n  let hasRun = false;\n  return async () => {\n    if (!hasRun) {\n      hasRun = true;\n      cache = await fn();\n    }\n    return cache;\n  };\n}\nfunction memorize(fn) {\n  let cache;\n  let hasRun = false;\n  return () => {\n    if (!hasRun) {\n      hasRun = true;\n      cache = fn();\n    }\n    return cache;\n  };\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  assert,\n  at,\n  blankObject,\n  clamp,\n  clampArrayRange,\n  clearUndefined,\n  createControlledPromise,\n  createEventHook,\n  customAlphabet,\n  debounce,\n  ensurePrefix,\n  ensureSuffix,\n  fillWith,\n  flattenArrayable,\n  getDeep,\n  hasOwnProperty,\n  hash,\n  isBoolean,\n  isBrowser,\n  isClient,\n  isDef,\n  isEmptyObject,\n  isError,\n  isFunction,\n  isKeyOf,\n  isLooseFalsy,\n  isLooseTruthy,\n  isNumber,\n  isObject,\n  isPromise,\n  isStrictFalsy,\n  isStrictTruthy,\n  isString,\n  isTruthy,\n  isWindow,\n  last,\n  lastPromiseFn,\n  lockPromiseFn,\n  memorize,\n  memorizePromise,\n  mergeArrayable,\n  move,\n  nanoid,\n  noNull,\n  noop,\n  notUndefined,\n  objectOmit,\n  objectPick,\n  partition,\n  range,\n  rangeWithStart,\n  remove,\n  retryPromiseFn,\n  run,\n  runAll,\n  runOnce,\n  singletonPromiseFn,\n  slash,\n  sleep,\n  sum,\n  throttle,\n  timestamp,\n  to,\n  toArray,\n  toString,\n  uniq,\n  uuid\n});\n"]}